From 48cbe6190a7ee3c006a5a4ff61d29e12ed670b2c Mon Sep 17 00:00:00 2001
From: Pratik Pachange <ppachang@qti.qualcomm.com>
Date: Thu, 20 Nov 2025 12:07:32 +0530
Subject: [PATCH 02/11] v4l2videoenc: Set format on capture queue before
 encoder negotiate call

- On encoder capture queue, if the pixformat to be set is different
from what is already set by default, then call S_FMT with expected
pixformat before calling gst_v4l2_video_enc_negotiate(). Otherwise
G_CTRL call to get profile and level will fail for the expected format.
(e.g. G_CTRL for hevc profile will fail if the format set on driver
is AVC)

- If the pixformat changes from what is already set by default on
driver, then extracontrols which were already set are reset and needs
to be set again.

- S_FMT is called on CAPTURE port first and then later, on the OUTPUT
port The width and height values set using S_FMT call are ignored by the
driver and it returns default values.
Later, when S_FMT is called on output port, video driver internally
reconfigures the capture port with the desired width and height and
updates the sizeimage of the capture buffers.
But this updated sizeimage value is not updated in the Gstvideoinfo
of v4l2object of capture side and the bufferpool created during
decide_allocation remains with the older value.
This is causing assertions when the encoded output is of bigger size
than the gst buffers of v4l2bufferpool.
So to resolve this issue call enc_negotiate after set_format on
output port.

Upstream-Status: Submitted [https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/10146 ]

Signed-off-by: Raja Ganapathi Busam <rbusam@qti.qualcomm.com>
---
 sys/v4l2/gstv4l2object.c   |  2 +-
 sys/v4l2/gstv4l2object.h   |  3 +++
 sys/v4l2/gstv4l2videoenc.c | 55 +++++++++++++++++++++++++++++++++++---
 sys/v4l2/v4l2_calls.c      |  2 +-
 4 files changed, 57 insertions(+), 5 deletions(-)

diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index ab37526..8b030bc 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -1966,7 +1966,7 @@ gst_v4l2_object_probe_template_caps (const gchar * device, gint video_fd,
  * @fps_n/@fps_d: location for framerate
  * @size: location for expected size of the frame or 0 if unknown
  */
-static gboolean
+gboolean
 gst_v4l2_object_get_caps_info (GstV4l2Object * v4l2object, GstCaps * caps,
     struct v4l2_fmtdesc **format, GstVideoInfoDmaDrm * info)
 {
diff --git a/sys/v4l2/gstv4l2object.h b/sys/v4l2/gstv4l2object.h
index 4b14b7e..7747b4d 100644
--- a/sys/v4l2/gstv4l2object.h
+++ b/sys/v4l2/gstv4l2object.h
@@ -374,6 +374,9 @@ gboolean     gst_v4l2_set_controls    (GstV4l2Object * v4l2object, GstStructure
 gboolean     gst_v4l2_subscribe_event (GstV4l2Object * v4l2object, guint32 event, guint32 id);
 gboolean     gst_v4l2_dequeue_event   (GstV4l2Object * v4l2object, struct v4l2_event *event);
 
+gboolean     gst_v4l2_fill_lists (GstV4l2Object * v4l2object);
+gboolean     gst_v4l2_object_get_caps_info (GstV4l2Object * v4l2object, GstCaps * caps, struct v4l2_fmtdesc **format, GstVideoInfoDmaDrm * info);
+
 G_END_DECLS
 
 #endif /* __GST_V4L2_OBJECT_H__ */
diff --git a/sys/v4l2/gstv4l2videoenc.c b/sys/v4l2/gstv4l2videoenc.c
index 8eedd46..f3697cd 100644
--- a/sys/v4l2/gstv4l2videoenc.c
+++ b/sys/v4l2/gstv4l2videoenc.c
@@ -106,6 +106,53 @@ gst_v4l2_video_enc_get_property (GObject * object,
   }
 }
 
+static void
+gst_v4l2_video_enc_set_cap_fmt (GstVideoEncoder * encoder)
+{
+  GstV4l2VideoEnc *self = GST_V4L2_VIDEO_ENC (encoder);
+  GstV4l2Object *v4l2capture = GST_V4L2_OBJECT (self->v4l2capture);
+  GstCaps *caps;
+  GstVideoInfoDmaDrm info;
+  struct v4l2_format format;
+  struct v4l2_fmtdesc *fmtdesc;
+
+  gst_video_info_dma_drm_init (&info);
+  caps = gst_caps_copy (gst_pad_get_pad_template_caps (encoder->srcpad));
+  caps = gst_caps_fixate (caps);
+  if (!gst_v4l2_object_get_caps_info (v4l2capture, caps, &fmtdesc, &info))
+    goto done;
+
+  memset (&format, 0x00, sizeof (struct v4l2_format));
+  format.type = v4l2capture->type;
+  if (v4l2capture->ioctl (v4l2capture->video_fd, VIDIOC_G_FMT, &format) < 0) {
+    GST_DEBUG_OBJECT (self, "Call to VIDIOC_G_FMT failed with error %s",
+        g_strerror (errno));
+    goto done;
+  }
+
+  if (format.fmt.pix.pixelformat != fmtdesc->pixelformat) {
+    format.fmt.pix.pixelformat = fmtdesc->pixelformat;
+    if (v4l2capture->ioctl (v4l2capture->video_fd, VIDIOC_S_FMT, &format) < 0) {
+      GST_DEBUG_OBJECT (self, "Call to VIDIOC_S_FMT failed for format %"
+          GST_FOURCC_FORMAT " with error %s",
+          GST_FOURCC_ARGS (format.fmt.pix.pixelformat), g_strerror (errno));
+      goto done;
+    }
+    GST_DEBUG_OBJECT (self, "pixelformat set to %" GST_FOURCC_FORMAT,
+        GST_FOURCC_ARGS (format.fmt.pix.pixelformat));
+
+    /* If the pixformat changes, we might have to set extra-controls again */
+    gst_v4l2_fill_lists (self->v4l2output);
+    if (self->v4l2output->extra_controls) {
+      gst_v4l2_set_controls (self->v4l2output,
+          self->v4l2output->extra_controls);
+    }
+  }
+
+done:
+  gst_caps_unref (caps);
+}
+
 static gboolean
 gst_v4l2_video_enc_open (GstVideoEncoder * encoder)
 {
@@ -121,6 +168,8 @@ gst_v4l2_video_enc_open (GstVideoEncoder * encoder)
   if (!gst_v4l2_object_open_shared (self->v4l2capture, self->v4l2output))
     goto failure;
 
+  gst_v4l2_video_enc_set_cap_fmt (encoder);
+
   self->probed_sinkcaps = gst_v4l2_object_probe_caps (self->v4l2output,
       gst_v4l2_object_get_raw_caps ());
 
@@ -357,14 +406,14 @@ gst_v4l2_video_enc_set_format (GstVideoEncoder * encoder,
   output = gst_video_encoder_set_output_state (encoder, outcaps, state);
   gst_video_codec_state_unref (output);
 
-  if (!gst_video_encoder_negotiate (encoder))
-    return FALSE;
-
   if (!gst_v4l2_object_set_format (self->v4l2output, state->caps, &error)) {
     gst_v4l2_error (self, &error);
     return FALSE;
   }
 
+  if (!gst_video_encoder_negotiate (encoder))
+    return FALSE;
+
   /* best effort */
   gst_v4l2_object_setup_padding (self->v4l2output);
 
diff --git a/sys/v4l2/v4l2_calls.c b/sys/v4l2/v4l2_calls.c
index a6527e4..8b84fdb 100644
--- a/sys/v4l2/v4l2_calls.c
+++ b/sys/v4l2/v4l2_calls.c
@@ -125,7 +125,7 @@ gst_v4l2_normalise_control_name (gchar * name)
  *   fill/empty the lists of enumerations
  * return value: TRUE on success, FALSE on error
  ******************************************************/
-static gboolean
+gboolean
 gst_v4l2_fill_lists (GstV4l2Object * v4l2object)
 {
   gint n, next;
-- 
2.34.1
