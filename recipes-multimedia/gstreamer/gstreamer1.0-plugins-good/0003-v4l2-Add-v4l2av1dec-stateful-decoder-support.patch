From 06da3492fecda4777ee7cd121571da25b4a88624 Mon Sep 17 00:00:00 2001
From: DEEPA GUTHYAPPA MADIVALARA <deepa.madivalara@oss.qualcomm.com>
Date: Wed, 20 Aug 2025 14:23:51 -0700
Subject: [PATCH 03/11] v4l2: Add v4l2av1dec stateful decoder support

Introduce support for new pixelformat V4L2_PIX_FMT_AV1 which maps
to V4l2 AV1 stateful decoder. Implement necessary changes to
enable v4l2av1dec component.

Part-of: <https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/9892>

Upstream-Status: Submitted [https://gitlab.freedesktop.org/gstreamer/gstreamer/-/merge_requests/9892 ]

Signed-off-by: Raja Ganapathi Busam <rbusam@qti.qualcomm.com>
---
 sys/v4l2/ext/videodev2.h   |   1 +
 sys/v4l2/gstv4l2av1codec.c | 201 +++++++++++++++++++++++++++++++++++++
 sys/v4l2/gstv4l2av1codec.h |  36 +++++++
 sys/v4l2/gstv4l2object.c   |   8 ++
 sys/v4l2/gstv4l2videodec.c |   4 +
 sys/v4l2/meson.build       |   2 +
 6 files changed, 252 insertions(+)
 create mode 100644 sys/v4l2/gstv4l2av1codec.c
 create mode 100644 sys/v4l2/gstv4l2av1codec.h

diff --git a/sys/v4l2/ext/videodev2.h b/sys/v4l2/ext/videodev2.h
index 2ceb1ca..8d94059 100644
--- a/sys/v4l2/ext/videodev2.h
+++ b/sys/v4l2/ext/videodev2.h
@@ -732,6 +732,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_FWHT_STATELESS     v4l2_fourcc('S', 'F', 'W', 'H') /* Stateless FWHT (vicodec) */
 #define V4L2_PIX_FMT_H264_SLICE v4l2_fourcc('S', '2', '6', '4') /* H264 parsed slices */
 #define V4L2_PIX_FMT_HEVC_SLICE v4l2_fourcc('S', '2', '6', '5') /* HEVC parsed slices */
+#define V4L2_PIX_FMT_AV1       v4l2_fourcc('A', 'V', '0', '1') /* AV1 */
 #define V4L2_PIX_FMT_AV1_FRAME v4l2_fourcc('A', 'V', '1', 'F') /* AV1 parsed frame */
 #define V4L2_PIX_FMT_SPK      v4l2_fourcc('S', 'P', 'K', '0') /* Sorenson Spark */
 #define V4L2_PIX_FMT_RV30     v4l2_fourcc('R', 'V', '3', '0') /* RealVideo 8 */
diff --git a/sys/v4l2/gstv4l2av1codec.c b/sys/v4l2/gstv4l2av1codec.c
new file mode 100644
index 0000000..4f2a5ee
--- /dev/null
+++ b/sys/v4l2/gstv4l2av1codec.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2022 Synaptics Incorporated
+ *    Author: Hsia-Jun(Randy) Li <randy.li@synaptics.com>
+ * Copyright (C) 2025 Qualcomm Technologies, Inc. and/or its subsidiaries.
+ *    Author: Deepa Guthyappa Madivalara <deepa.madivalara@oss.qualcomm.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstv4l2av1codec.h"
+
+#include <gst/gst.h>
+#include "ext/v4l2-controls.h"
+
+static gint
+v4l2_profile_from_string (const gchar * profile)
+{
+  gint v4l2_profile = -1;
+
+  if (g_str_equal (profile, "main"))
+    v4l2_profile = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN;
+  else if (g_str_equal (profile, "high"))
+    v4l2_profile = V4L2_MPEG_VIDEO_AV1_PROFILE_HIGH;
+  else if (g_str_equal (profile, "professional"))
+    v4l2_profile = V4L2_MPEG_VIDEO_AV1_PROFILE_PROFESSIONAL;
+  else
+    GST_WARNING ("Unsupported profile string '%s'", profile);
+
+  return v4l2_profile;
+}
+
+static const gchar *
+v4l2_profile_to_string (gint v4l2_profile)
+{
+  switch (v4l2_profile) {
+    case V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN:
+      return "main";
+    case V4L2_MPEG_VIDEO_AV1_PROFILE_HIGH:
+      return "high";
+    case V4L2_MPEG_VIDEO_AV1_PROFILE_PROFESSIONAL:
+      return "professional";
+    default:
+      GST_WARNING ("Unsupported V4L2 profile %i", v4l2_profile);
+      break;
+  }
+
+  return NULL;
+}
+
+static gint
+v4l2_level_from_string (const gchar * level)
+{
+  gint v4l2_level = -1;
+
+  if (g_str_equal (level, "2.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_0;
+  else if (g_str_equal (level, "2.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_1;
+  else if (g_str_equal (level, "2.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_2;
+  else if (g_str_equal (level, "2.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_3;
+  else if (g_str_equal (level, "3.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_0;
+  else if (g_str_equal (level, "3.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_1;
+  else if (g_str_equal (level, "3.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_2;
+  else if (g_str_equal (level, "3.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_3;
+  else if (g_str_equal (level, "4.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_0;
+  else if (g_str_equal (level, "4.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_1;
+  else if (g_str_equal (level, "4.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_2;
+  else if (g_str_equal (level, "4.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_3;
+  else if (g_str_equal (level, "5.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_0;
+  else if (g_str_equal (level, "5.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_1;
+  else if (g_str_equal (level, "5.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_2;
+  else if (g_str_equal (level, "5.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_3;
+  else if (g_str_equal (level, "6.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_0;
+  else if (g_str_equal (level, "6.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_1;
+  else if (g_str_equal (level, "6.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_2;
+  else if (g_str_equal (level, "6.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_3;
+  else if (g_str_equal (level, "7.0"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_0;
+  else if (g_str_equal (level, "7.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_1;
+  else if (g_str_equal (level, "7.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_2;
+  else if (g_str_equal (level, "7.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_3;
+  else
+    GST_WARNING ("Unsupported level '%s'", level);
+
+  return v4l2_level;
+}
+
+static const gchar *
+v4l2_level_to_string (gint v4l2_level)
+{
+  switch (v4l2_level) {
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_0:
+      return "2.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_1:
+      return "2.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_2:
+      return "2.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_3:
+      return "2.3";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_3_0:
+      return "3.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_3_1:
+      return "3.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_3_2:
+      return "3.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_3_3:
+      return "3.3";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_4_0:
+      return "4.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_4_1:
+      return "4.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_4_2:
+      return "4.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_4_3:
+      return "4.3";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_5_0:
+      return "5.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_5_1:
+      return "5.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_5_2:
+      return "5.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_5_3:
+      return "5.3";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_6_0:
+      return "6.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_6_1:
+      return "6.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_6_2:
+      return "6.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_6_3:
+      return "6.3";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_7_0:
+      return "7.0";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_7_1:
+      return "7.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_7_2:
+      return "7.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_7_3:
+      return "7.3";
+    default:
+      GST_WARNING ("Unsupported V4L2 level %i", v4l2_level);
+      break;
+  }
+
+  return NULL;
+}
+
+const GstV4l2Codec *
+gst_v4l2_av1_get_codec (void)
+{
+  static GstV4l2Codec *codec = NULL;
+  if (g_once_init_enter (&codec)) {
+    static GstV4l2Codec c;
+    c.profile_cid = V4L2_CID_MPEG_VIDEO_AV1_PROFILE;
+    c.profile_to_string = v4l2_profile_to_string;
+    c.profile_from_string = v4l2_profile_from_string;
+    c.level_cid = V4L2_CID_MPEG_VIDEO_AV1_LEVEL;
+    c.level_to_string = v4l2_level_to_string;
+    c.level_from_string = v4l2_level_from_string;
+    g_once_init_leave (&codec, &c);
+  }
+  return codec;
+}
diff --git a/sys/v4l2/gstv4l2av1codec.h b/sys/v4l2/gstv4l2av1codec.h
new file mode 100644
index 0000000..b6cf236
--- /dev/null
+++ b/sys/v4l2/gstv4l2av1codec.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2022 Synaptics Incorporated
+ *    Author: Hsia-Jun(Randy) Li <randy.li@synaptics.com>
+ * Copyright (C) 2025 Qualcomm Technologies, Inc. and/or its subsidiaries.
+ *    Author: Deepa Guthyappa Madivalara <deepa.madivalara@oss.qualcomm.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#ifndef __GST_V4L2_AV1_CODEC_H__
+#define __GST_V4L2_AV1_CODEC_H__
+
+#include "gstv4l2codec.h"
+
+G_BEGIN_DECLS
+
+const GstV4l2Codec * gst_v4l2_av1_get_codec (void);
+
+G_END_DECLS
+
+#endif
diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index 8b030bc..d823337 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -236,6 +236,7 @@ static GstV4L2FormatDesc gst_v4l2_formats[] = {
   {MAP_ENC_FMT (VC1_ANNEX_L, ENCODED),  GST_V4L2_CODEC},
   {MAP_ENC_FMT (VP8, ENCODED),          GST_V4L2_CODEC | GST_V4L2_NO_PARSE},
   {MAP_ENC_FMT (VP9, ENCODED),          GST_V4L2_CODEC | GST_V4L2_NO_PARSE},
+  {MAP_ENC_FMT (AV1, ENCODED),          GST_V4L2_CODEC},

   /*  Vendor-specific formats   */
   {MAP_ENC_FMT (WNVA, ENCODED),     GST_V4L2_CODEC | GST_V4L2_RESOLUTION_AND_RATE},
@@ -1596,6 +1597,11 @@ gst_v4l2_object_v4l2fourcc_to_bare_struct (guint32 fourcc,
     case V4L2_PIX_FMT_VP9:
       structure = gst_structure_new_empty ("video/x-vp9");
       break;
+    case V4L2_PIX_FMT_AV1:
+      structure = gst_structure_new ("video/x-av1",
+          "stream-format", G_TYPE_STRING, "obu-stream", "alignment",
+          G_TYPE_STRING, "tu", NULL);
+      break;
     case V4L2_PIX_FMT_DV:
       structure =
           gst_structure_new ("video/x-dv", "systemstream", G_TYPE_BOOLEAN, TRUE,
@@ -2058,6 +2064,8 @@ gst_v4l2_object_get_caps_info (GstV4l2Object * v4l2object, GstCaps * caps,
     fourcc = V4L2_PIX_FMT_VP8;
   } else if (g_str_equal (mimetype, "video/x-vp9")) {
     fourcc = V4L2_PIX_FMT_VP9;
+  } else if (g_str_equal (mimetype, "video/x-av1")) {
+    fourcc = V4L2_PIX_FMT_AV1;
   } else if (g_str_equal (mimetype, "video/x-bayer")) {
     const gchar *format = gst_structure_get_string (structure, "format");
     if (format) {
diff --git a/sys/v4l2/gstv4l2videodec.c b/sys/v4l2/gstv4l2videodec.c
index 071f8a4..d74f3e7 100644
--- a/sys/v4l2/gstv4l2videodec.c
+++ b/sys/v4l2/gstv4l2videodec.c
@@ -38,6 +38,7 @@
 #include "gstv4l2mpeg4codec.h"
 #include "gstv4l2vp8codec.h"
 #include "gstv4l2vp9codec.h"
+#include "gstv4l2av1codec.h"

 #include <string.h>
 #include <glib/gi18n-lib.h>
@@ -1455,6 +1456,9 @@ G_STMT_START { \
   } else if (gst_structure_has_name (s, "video/x-vp9")) {
     SET_META ("VP9");
     cdata->codec = gst_v4l2_vp9_get_codec ();
+  } else if (gst_structure_has_name (s, "video/x-av1")) {
+    SET_META ("AV1");
+    cdata->codec = gst_v4l2_av1_get_codec ();
   } else if (gst_structure_has_name (s, "video/x-bayer")) {
     SET_META ("BAYER");
   } else if (gst_structure_has_name (s, "video/x-sonix")) {
diff --git a/sys/v4l2/meson.build b/sys/v4l2/meson.build
index 61a6f05..2d6cbb3 100644
--- a/sys/v4l2/meson.build
+++ b/sys/v4l2/meson.build
@@ -29,6 +29,7 @@ v4l2_sources = [
   'gstv4l2vp8enc.c',
   'gstv4l2vp9codec.c',
   'gstv4l2vp9enc.c',
+  'gstv4l2av1codec.c',
   'v4l2_calls.c',
   'v4l2-utils.c',
   'tuner.c',
@@ -64,6 +65,7 @@ v4l2_headers = [
   'tunerchannel.h',
   'gstv4l2videoenc.h',
   'gstv4l2h264codec.h',
+  'gstv4l2av1codec.h',
   'gstv4l2src.h',
   'tuner.h',
   'gstv4l2mpeg4codec.h',
--
2.34.1
